# Spec 工作流程指南（Sub Agent 驱动版）

本指南覆盖全局 spec-workflow skill，定义使用 Sub Agent 驱动模式执行 Spec 任务的完整工作流程。
当本文档与全局 spec-workflow 冲突时，以本文档为准。

## 一、Spec 创建前：需求澄清

### 1.1 激活 Skills

在创建任何 spec 之前，必须先激活 `brainstorming` 以及其他能够用得到的 Skills，与用户进行深入的需求探讨。

### 1.2 需求澄清问题清单

向用户询问以下关键问题：

**功能范围**
- 这个功能要解决什么问题？
- 预期的用户场景是什么？
- 功能的边界在哪里？

**技术考量**
- 是否有现有代码需要修改或重构？
- 是否涉及数据模型变更？
- 对性能有什么要求？

**验收标准**
- 如何判断功能完成？
- 需要哪些测试覆盖？

### 1.3 记录讨论结果

将头脑风暴的结果整理到 spec 的 requirements.md 中。

## 二、Spec 创建：规范命名

### 2.1 Spec 编号规则

- 每个工作区的 spec 从 1 开始递增
- 查看 `.kiro/specs/` 目录确定下一个可用编号
- 目录命名格式：`{编号}-{简短描述}`

### 2.2 Spec 目录结构

```
.kiro/specs/{编号}-{描述}/
├── requirements.md    # 需求文档
├── design.md          # 设计文档
└── tasks.md           # 任务清单
```

## 三、开发前：分支管理

### 3.1 创建开发分支

```bash
git checkout main
git pull origin main
git checkout -b {type}/{编号}-{描述}
```

### 3.2 分支类型选择

- `feature/` - 新功能开发（spec 主要是 feat）
- `fix/` - Bug 修复（spec 主要是 fix）
- `refactor/` - 代码重构（spec 主要是 refactor）

## 四、任务执行：Sub Agent 驱动模式

### 4.1 核心原则

**sub agent 只负责编码，主代理负责审查和提交。**

| 角色 | 职责 | 禁止操作 |
|------|------|---------|
| 主代理（你） | 读取计划、分派任务、代码审查、编译验证、git 提交、更新 tasks.md | 不直接写大量业务代码 |
| Sub Agent | 阅读源码、编码实现、编译验证、输出开发报告 | 不执行 git 操作、不修改 spec 文件 |

### 4.2 单个 Task 的执行流程

```
1. 主代理：读取计划文件，提取当前 Task 的完整描述
2. 主代理：分析 Task 结构，判断是否包含可并行的子任务（见 4.8）
3. 主代理：派发 sub agent（单个或多个并行）
4. Sub Agent：阅读源码 -> 编码实现 -> 编译验证 -> 输出开发报告
5. 主代理：审查 sub agent 的开发报告（见 4.4）
   - 有问题 -> 主代理修复小问题 / 重新派发 sub agent 修复大问题
   - 通过 -> 继续
6. 主代理：自行运行编译验证
7. 主代理：执行 git 提交（使用计划中指定的提交信息）
8. 主代理：更新 tasks.md 标记任务完成
9. 进入下一个 Task
```

### 4.3 派发 Sub Agent 的方法

使用 `invokeSubAgent` 工具，name 为 `general-task-execution`，prompt 格式：

```
你是 MiNoteMac 项目的开发 agent。请严格按照以下指令执行。

## 执行指令
请阅读 `.kiro/agents/spec-task-implementer.md` 获取完整的执行规则和代码规范。

## 当前任务

### Task N：[任务标题]

[从计划文件中复制的完整 Task 描述，包括：
- 创建文件清单
- 修改文件清单
- 删除文件清单
- 实现要求
- 必须删除的代码（如有）
- 验证清单
- 提交信息（仅供参考，你不需要执行 git 操作）]

## 上下文

[说明这个 Task 在整体计划中的位置，前置 Task 已完成的内容，
当前代码库的状态，需要注意的依赖关系]

## 关联文件
- 计划文件：[路径]
- 设计文档：[路径]
- 其他参考：[路径]

## 重要提醒
- 不要执行任何 git 操作（git add / commit / push 等）
- 不要修改 .kiro/specs/ 下的文件
- 编码完成后输出开发报告
```

### 4.4 主代理代码审查清单

Sub agent 完成编码后，主代理必须逐项审查：

**规范检查**
- [ ] 代码中无 emoji、无 `print()`、无 `[[调试]]` 前缀
- [ ] 日志使用 `LogService.shared`，模块标识正确
- [ ] 注释使用中文，只在复杂逻辑处添加
- [ ] 命名符合规范（PascalCase 类型、camelCase 变量）

**反模式检查**
- [ ] 无包装器模式（新方法有完整实现，不是一行调用旧方法）
- [ ] 无只加不减（计划中要求删除的代码已删除）
- [ ] 无双重发布（新旧机制没有同时存在）
- [ ] 无空方法占位（每个方法有完整实现）

**功能检查**
- [ ] 验证清单中的每一项都通过
- [ ] 编译通过（主代理自行验证一次）
- [ ] 计划外的修改合理且必要

**并发安全检查**
- [ ] 需要线程安全的组件使用了 Actor
- [ ] UI 相关的 State 对象标记了 @MainActor
- [ ] 所有类型符合 Sendable 要求

### 4.5 审查不通过的处理

**小问题（1-3 处修改）**：主代理直接修复。

**大问题（逻辑错误、遗漏大量代码）**：重新派发 sub agent，在 prompt 中明确指出问题：

```
上一次实现存在以下问题，请修复：
1. [具体问题描述，附文件路径和行号]
2. [具体问题描述]

请在修复后重新输出完整的开发报告。
```

**反模式问题**：必须重新派发 sub agent，明确要求避免该反模式，并给出正确做法的示例。

### 4.6 审查通过后的提交

```bash
# 1. 如果有文件增删，先运行 xcodegen
xcodegen generate

# 2. 编译验证
xcodebuild -project MiNoteMac.xcodeproj -scheme MiNoteMac -configuration Debug build 2>&1 | tail -30

# 3. 提交（使用计划中指定的提交信息）
git add -A
git commit -m "<type>(<scope>): <subject>"

# 4. 更新 tasks.md 标记任务完成
```

### 4.7 简单任务的直接执行

对于非常简单的任务（只修改 1-2 个文件、改动不超过 20 行），主代理可以直接执行，不需要派发 sub agent。

### 4.8 并行子任务执行

当一个 Task 包含多个子任务（如 Task 1.1、1.2、1.3）时，主代理应分析是否可以并行执行。

#### 并行条件判断

子任务满足以下所有条件时，可以并行派发：

1. 无文件交叉：各子任务创建/修改的文件集合没有交集
2. 无数据依赖：子任务 B 不依赖子任务 A 的输出（如 A 创建的类型、协议）
3. 无顺序约束：计划中没有明确要求先后执行

#### 判断流程

```
1. 提取每个子任务的文件清单（创建 + 修改 + 删除）
2. 检查文件集合是否有交集
   - 有交集 -> 串行执行
   - 无交集 -> 继续检查
3. 检查类型/协议依赖
   - 子任务 B 引用了子任务 A 新创建的类型 -> 串行执行
   - 无依赖 -> 可以并行
```

#### 并行派发方法

在同一轮对话中同时调用多个 `invokeSubAgent`：

```
# 同时派发 Task 1.1 和 Task 1.2
invokeSubAgent(name="general-task-execution", prompt="...Task 1.1...")
invokeSubAgent(name="general-task-execution", prompt="...Task 1.2...")
```

每个子代理的 prompt 中需要额外说明：

```
## 并行执行说明
本任务与 Task 1.2 并行执行。你只需关注自己的任务范围，不要修改以下文件（由其他子代理负责）：
- [其他子代理负责的文件列表]
```

#### 结果合并与冲突处理

所有并行子代理完成后，主代理需要：

1. 逐个审查每个子代理的开发报告
2. 检查是否有意外的文件冲突（子代理修改了计划外的共享文件）
3. 如果有冲突：
   - 小冲突（如 import 语句）：主代理手动合并
   - 大冲突（逻辑冲突）：回退其中一个子代理的修改，串行重新执行
4. 统一编译验证（所有并行子任务合并后编译一次）
5. 统一提交（所有并行子任务合并为一个 commit，或按子任务分别提交）

#### 示例

假设 Task 3 包含三个子任务：

| 子任务 | 创建文件 | 修改文件 | 依赖 |
|--------|---------|---------|------|
| 3.1 创建 UserService | UserService.swift | - | 无 |
| 3.2 创建 NoteService | NoteService.swift | - | 无 |
| 3.3 迁移 ViewModel | - | NotesViewModel.swift | 依赖 3.1 和 3.2 |

分析结果：
- 3.1 和 3.2 无交集、无依赖 -> 并行执行
- 3.3 依赖 3.1 和 3.2 的产出 -> 等 3.1、3.2 完成后串行执行

执行顺序：`[3.1 + 3.2 并行] -> 审查合并 -> 3.3 串行`

## 五、完成后：提交与合并

### 5.1 更新 Spec 状态

在 tasks.md 中标记所有任务为完成状态。

### 5.2 合并

```bash
git checkout main
git merge --no-ff {branch-name}
git branch -d {branch-name}
```

### 5.3 文档更新

如果 spec 涉及架构变化，同步更新：
- `.kiro/steering/tech.md`
- `AGENTS.md`
- `CHANGELOG.md`

## 六、常见问题处理

### 6.1 Spec 范围变更

暂停实现 -> 与用户讨论 -> 更新 requirements.md 和 tasks.md -> 继续

### 6.2 遇到阻塞问题

记录问题 -> 查阅文档 -> 与用户讨论替代方案

### 6.3 Sub Agent 执行失败

1. 分析失败原因（任务描述不清晰？代码依赖复杂？）
2. 将任务拆分为更小的子任务
3. 为 sub agent 提供更详细的上下文
4. 必要时主代理直接接手
